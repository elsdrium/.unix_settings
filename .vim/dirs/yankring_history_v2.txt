window/state = '000000ff00000000fd000000010000000000000780000003c7fc0200000001fc0000002c000003c70000016100fffffffc0100000004fb0000002400500072006f006a006500630074004500780070006c006f007200650072005f006400770000000000ffffffff0000004e00fffffffb000000120045006400690074006f0072005f006400770100000000000005a50000009d00fffffffb00000024004f00750074006c0069006e0065004500780070006c006f007200650072005f006400770000000000ffffffff0000006400fffffffc000005a6000001da000000f400fffffffc0200000002fc0000002c000001d2000000c501000014fa000000000200000008fb00000024004f0062006a0065006300740049006e00730070006500630074006f0072005f006400770100000000ffffffff0000008a00fffffffb00000026005600610072006900610062006c0065004500780070006c006f007200650072005f006400770100000000ffffffff000000b000fffffffb0000001a004f006e006c0069006e006500480065006c0070005f006400770000000000ffffffff0000003c00fffffffb00000016004500780070006c006f007200650072005f006400770100000000ffffffff0000008300fffffffb0000001c00460069006e00640049006e00460069006c00650073005f006400770000000000ffffffff000000d600fffffffb0000001c0042007200650061006b0070006f0069006e00740073005f006400770000000000ffffffff0000006400fffffffb0000001600500072006f00660069006c00650072005f006400770000000000ffffffff000000a700fffffffb0000001200500079006c0069006e0074005f006400770000000000ffffffff000000a700fffffffc000001ff000001f40000009b01000014fa000000030200000004fb000000140043006f006e0073006f006c0065005f006400770000000000ffffffff0000006400fffffffb0000002400450078007400650072006e0061006c0043006f006e0073006f006c0065005f006400770100000000ffffffff0000008600fffffffb0000001a0048006900730074006f00720079004c006f0067005f006400770100000000ffffffff0000008600fffffffb0000002200490050007900740068006f006e0043006f006e0073006f006c0065005f006400770100000000ffffffff0000008600ffffff00000000000003c700000004000000040000000800000008fc0000000100000002000000080000001800660069006c0065005f0074006f006f006c0062006100720100000000ffffffff0000000000000000000000180065006400690074005f0074006f006f006c0062006100720000000000ffffffff00000000000000000000001c007300650061007200630068005f0074006f006f006c0062006100720000000000ffffffff00000000000000000000001c0073006f0075007200630065005f0074006f006f006c0062006100720000000000ffffffff00000000000000000000001600720075006e005f0074006f006f006c00620061007201000000a1ffffffff00000000000000000000001a00640065006200750067005f0074006f006f006c0062006100720100000168ffffffff000000000000000000000018006d00610069006e005f0074006f006f006c0062006100720100000255ffffffff0000000000000000000000300047006c006f00620061006c00200077006f0072006b0069006e00670020006400690072006500630074006f007200790100000300ffffffff0000000000000000',V
window/state = 000000ff00000000fd000000010000000000000780000003c7fc0200000001fc0000002c000003c70000016100fffffffc0100000005fc0000000000000157000000da00fffffffc0200000002fb00000016004500780070006c006f007200650072005f00640077010000002c000002260000008300fffffffc00000253000001a0000000bc01000014fa000000000100000002fb00000024004f0062006a0065006300740049006e00730070006500630074006f0072005f006400770100000000ffffffff000000a100fffffffb0000001200500079006c0069006e0074005f00640077010000000000000157000000da00fffffffb000000120045006400690074006f0072005f0064007701000001580000044d0000009d00fffffffb0000002400500072006f006a006500630074004500780070006c006f007200650072005f0064007700000004bd0000012e0000004e00fffffffb00000024004f00750074006c0069006e0065004500780070006c006f007200650072005f006400770000000000ffffffff0000006400fffffffc000005a6000001da000000d200fffffffc0200000003fc0000002c000002be000000c501000014fa000000010100000002fb00000026005600610072006900610062006c0065004500780070006c006f007200650072005f006400770100000000ffffffff0000006b00fffffffb0000001600500072006f00660069006c00650072005f0064007701000004750000030b000000d200fffffffc00000273000000a40000000000fffffffaffffffff0200000003fb0000001a004f006e006c0069006e006500480065006c0070005f006400770000000000ffffffff0000003c00fffffffb0000001c00460069006e00640049006e00460069006c00650073005f006400770000000000ffffffff000000d600fffffffb0000001c0042007200650061006b0070006f0069006e00740073005f006400770000000000ffffffff0000006400fffffffc000002eb000001080000009b01000014fa000000020200000004fb0000002400450078007400650072006e0061006c0043006f006e0073006f006c0065005f006400770000000000ffffffff0000003300fffffffb000000140043006f006e0073006f006c0065005f006400770000000000ffffffff0000006400fffffffb0000002200490050007900740068006f006e0043006f006e0073006f006c0065005f006400770100000000ffffffff0000003800fffffffb0000001a0048006900730074006f00720079004c006f0067005f006400770100000000ffffffff0000008600ffffff00000000000003c700000004000000040000000800000008fc00000001000000020000000800000018006d00610069006e005f0074006f006f006c0062006100720100000000ffffffff00000000000000000000001800660069006c0065005f0074006f006f006c00620061007201000000abffffffff0000000000000000000000180065006400690074005f0074006f006f006c0062006100720000000000ffffffff00000000000000000000001c007300650061007200630068005f0074006f006f006c006200610072010000014cffffffff00000000000000000000001c0073006f0075007200630065005f0074006f006f006c006200610072010000021dffffffff00000000000000000000001600720075006e005f0074006f006f006c0062006100720000000000ffffffff00000000000000000000001a00640065006200750067005f0074006f006f006c0062006100720100000352ffffffff0000000000000000000000300047006c006f00620061006c00200077006f0072006b0069006e00670020006400690072006500630074006f00720079010000043fffffffff0000000000000000,V
memory_usage/enable = True,V
pu_usage/enable = False,V
[main]window/prefs_dialog_size = (1145, 613)show_internal_console_if_traceback = Truelightwindow/size = (650, 400)window/is_fullscreen = Falsecpu_usage/timeout = 2000memory_usage/timeout = 2000window/is_maximized = Truesingle_instance = Truewindow/size = (1260, 740)window/position = (10, 10)vertical_dockwidget_titlebars = Falselightwindow/is_maximized = Falseanimated_docks = Truelightwindow/prefs_dialog_size = (745, 411)c,v
emory_usage/enable = True,V
[main]window/prefs_dialog_size = (1145, 613)show_internal_console_if_traceback = Truelightwindow/size = (650, 400)window/is_fullscreen = Falsecpu_usage/timeout = 2000memory_usage/timeout = 2000window/is_maximized = Truesingle_instance = Truewindow/size = (1260, 740)window/position = (10, 10)vertical_dockwidget_titlebars = Falselightwindow/is_maximized = Falseanimated_docks = Truelightwindow/prefs_dialog_size = (745, 411)cpu_usage/enable = Falsem,v
24 ,v
23 ,v
22 ,v
21 ,v
20 ,v
19 ,v
18 ,v
17 ,v
16 ,v
15 ,v
14 ,v
 ,v
3,v
1,v
2,v
0,v
9,v
8,v
7,v
6,v
5,v
4,v
animated_docks = True,V
1 [main]  2 lightwindow/size = (650, 400)  3 tear_off_menus = False  4 lightwindow/is_fullscreen = False  5 window/prefs_dialog_size = (745, 580)  6 memory_usage/timeout = 2000  7 custom_margin = 0  8 animated_docks = True  9 lightwindow/prefs_dialog_size = (745, 411) 10 cpu_usage/enable = True 11 use_custom_margin = True 12 vertical_tabs = False 13 vertical_dockwidget_titlebars = False 14 single_instance = True 15 open_files_port = 21128 16 window/position = (10, 23) 17 show_internal_console_if_traceback = True 18 window/size = (1918, 1031) 19 lightwindow/is_maximized = False 20 lightwindow/position = (30, 30) 21 memory_usage/enable = True 22 window/is_maximized = True 23 cpu_usage/timeout = 2000 24 window/is_fullscreen = False,v
pythonstartup = /Applications/Spyder.app/Contents/Resources/lib/python2.7/spyderlib/scientific_startup.py,V
',v
http://zh.wikipedia.org/wiki/%E8%94%A1%E4%BB%81%E5%A0%85,v
\author{Hsueh-Min Chen},V
http://apps.facebook.com/happyfishbowl/artifact.do?src=feed_artifact_help&method=help&uid=3532190&lg=zh_TW&sign=43380a103e41893548a216ca105cd804&viral_id=100000033743851_1416187582084&fish_msg_type=feed,v
b,v
http://www.paulgraham.com/startupideas.html,v
>,v
h,v
-,v
A,v
<,v
l,v
##Paper<br />####1. Sparse Representation for Music Information Retrieval using a Large Scale Dictionary (PK's paper)<br /> * The efficiency bottleneck may caused by MATLAB's slow loop iterations.<br /> ####2. AWtoolbox: Characterizing Audio Information Using Audio Words (Mike's paper)<br /> * GUI using C# is Windows-only and not advantageous for distributing.<br /> ####3. A Compositional Hierarchical Model for Music Information Retrieval (ISMIR 2014)<br /> * It proposes a multi-layer model which is similar to deep learning but more transparent and interpretable.<br />,v
s,v
E,v
set convert-meta on,V
n,v
M,v
f,v
i,v
g,v
R,v
#,V
=,v
map <silent> <A-+> :vertical res +10,V
C:\Program Files\Vim\vim73\tutor\tutor,v
Plugin 'Plugin 'bling/vim-bufferline',v
Plugin 'bling/vim-bufferline',v
au FileType python set foldmethod=manual,V
Python 3.4.2 (default, Oct 19 2014, 17:55:38) Type "copyright", "credits" or "license" for more information. IPython 2.3.1 -- An enhanced Interactive Python.?         -> Introduction and overview of IPython's features.%quickref -> Quick reference.help      -> Python's own help system.object?   -> Details about 'object', use 'object??' for extra details. In [1]: pwd Out[1]: '/Users/elsdrm'In [2]: py.py ---------------------------------------------------------------------------NameError                                 Traceback (most recent call last)<ipython-input-2-74b753299131> in <module>()----> 1 py.py NameError: name 'py' is not defined In [3]: run WARNING: you must provide at least a filename. %run: Run the named file inside IPython as a program. Usage::  %run [-n -i -e -G]       [( -t [-N<N>] | -d [-b<N>] | -p [profile options] )]       ( -m mod | file ) [args]Parameters after the filename are passed as command-line arguments tothe program (put in sys.argv). Then, control returns to IPython'sprompt.This is similar to running at a system prompt ``python file args``,but with the advantage of giving you IPython's tracebacks, and ofloading all variables into your interactive namespace for further use(unless -p is used, see below).The file is executed in a namespace initially consisting only of``__name__=='__main__'`` and sys.argv constructed as indicated. It thussees its environment as if it were being run as a stand-alone program(except for sharing global objects such as previously importedmodules). But after execution, the IPython interactive namespace getsupdated with all variables defined in the program (except for __name__and sys.argv). This allows for very convenient loading of code forinteractive work, while giving each program a 'clean sheet' to run in.Arguments are expanded using shell-like glob match.  Patterns'*', '?', '[seq]' and '[!seq]' can be used.  Additionally,tilde '~' will be expanded into user's home directory.  Unlikereal shells, quotation does not suppress expansions.  Use*two* back slashes (e.g. ``\\*``) to suppress expansions.To completely disable these expansions, you can use -G flag.Options:-n  __name__ is NOT set to '__main__', but to the running file's name  without extension (as python does under import).  This allows running  scripts and reloading the definitions in them without calling code  protected by an ``if __name__ == "__main__"`` clause.-i  run the file in IPython's namespace instead of an empty one. This  is useful if you are experimenting with code written in a text editor  which depends on variables defined interactively.-e  ignore sys.exit() calls or SystemExit exceptions in the script  being run.  This is particularly useful if IPython is being used to  run unittests, which always exit with a sys.exit() call.  In such  cases you are interested in the output of the test results, not in  seeing a traceback of the unittest module.-t  print timing information at the end of the run.  IPython will give  you an estimated CPU time consumption for your script, which under  Unix uses the resource module to avoid the wraparound problems of  time.clock().  Under Unix, an estimate of time spent on system tasks  is also given (for Windows platforms this is reported as 0.0).If -t is given, an additional ``-N<N>`` option can be given, where <N>must be an integer indicating how many times you want the script torun.  The final timing report will include total and per run results.For example (testing the script uniq_stable.py)::    In [1]: run -t uniq_stable    IPython CPU timings (estimated):      User  :    0.19597 s.      System:        0.0 s.    In [2]: run -t -N5 uniq_stable    IPython CPU timings (estimated):    Total runs performed: 5      Times :      Total       Per run      User  :   0.910862 s,  0.1821724 s.      System:        0.0 s,        0.0 s.-d  run your program under the control of pdb, the Python debugger.  This allows you to execute your program step by step, watch variables,  etc.  Internally, what IPython does is similar to calling::      pdb.run('execfile("YOURFILENAME")')  with a breakpoint set on line 1 of your file.  You can change the line  number for this automatic breakpoint to be <N> by using the -bN option  (where N must be an integer). For example::      %run -d -b40 myscript  will set the first breakpoint at line 40 in myscript.py.  Note that  the first breakpoint must be set on a line which actually does  something (not a comment or docstring) for it to stop execution.  Or you can specify a breakpoint in a different file::      %run -d -b myotherfile.py:20 myscript  When the pdb debugger starts, you will see a (Pdb) prompt.  You must  first enter 'c' (without quotes) to start execution up to the first  breakpoint.  Entering 'help' gives information about the use of the debugger.  You  can easily see pdb's full documentation with "import pdb;pdb.help()"  at a prompt.-p  run program under the control of the Python profiler module (which  prints a detailed report of execution times, function calls, etc).  You can pass other options after -p which affect the behavior of the  profiler itself. See the docs for %prun for details.  In this mode, the program's variables do NOT propagate back to the  IPython interactive namespace (because they remain in the namespace  where the profiler executes them).  Internally this triggers a call to %prun, see its documentation for  details on the options available specifically for profiling.There is one special usage for which the text above doesn't apply:if the filename ends with .ipy[nb], the file is run as ipython script,just as if the commands were written on IPython prompt.-m  specify module name to load instead of script path. Similar to  the -m option for the python interpreter. Use this option last if you  want to combine with other %run options. Unlike the python interpreter  only source modules are allowed no .pyc or .pyo files.  For example::      %run -m example  will run the example module.-G  disable shell-like glob expansion of arguments.In [4]: run py.py I'm pig!Hello world.In [5]: run py.py I'm pig!It's not me.In [6]: import scipy im In [7]: import numpy  In [8]: import Cython  In [9]: Cython CythonIn [9]: Cython CythonIn [9]: Cython CythonIn [9]: Cython. Display all 141 possibilities? (y or n)Cython.ArrayType                 Cython.long                      Cython.ppp_Py_UNICODECython.CythonDotParallel         Cython.longdouble                Cython.ppp_Py_ssize_tCython.CythonMetaType            Cython.longdoublecomplex         Cython.ppp_bintCython.CythonType                Cython.longlong                  Cython.ppp_charCython.CythonTypeObject          Cython.name                      Cython.ppp_complexCython.NULL                      Cython.no_gc_clear               Cython.ppp_doubleCython.PointerType               Cython.nogil                     Cython.ppp_doublecomplexCython.Py_UCS4                   Cython.numeric                   Cython.ppp_floatCython.Py_UNICODE                Cython.other_types               Cython.ppp_floatcomplexCython.Py_ssize_t                Cython.p_Py_UCS4                 Cython.ppp_intCython.Shadow                    Cython.p_Py_UNICODE              Cython.ppp_longCython.StructType                Cython.p_Py_ssize_t              Cython.ppp_longdoubleCython.UnionType                 Cython.p_bint                    Cython.ppp_longdoublecomplexCython.address                   Cython.p_char                    Cython.ppp_longlongCython.array                     Cython.p_complex                 Cython.ppp_shortCython.bint                      Cython.p_double                  Cython.ppp_size_tCython.cast                      Cython.p_doublecomplex           Cython.ppp_voidCython.ccall                     Cython.p_float                   Cython.py_complexCython.cclass                    Cython.p_floatcomplex            Cython.py_floatCython.cdiv                      Cython.p_int                     Cython.py_intCython.cfunc                     Cython.p_long                    Cython.py_longCython.char                      Cython.p_longdouble              Cython.reprnameCython.cmod                      Cython.p_longdoublecomplex       Cython.returnsCython.compile                   Cython.p_longlong                Cython.scharCython.compiled                  Cython.p_short                   Cython.shortCython.complex                   Cython.p_size_t                  Cython.sintIn [11]:  ,V
    print( 'Hello world.' ),V
Python 3.4.2 (default, Oct 19 2014, 17:55:38) ,V
Type "copyright", "credits" or "license" for more information.,V
 ,V
IPython 2.3.1 -- An enhanced Interactive Python.,V
?         -> Introduction and overview of IPython's features.,V
In [1]:  ,V
object?   -> Details about 'object', use 'object??' for extra details.,V
help      -> Python's own help system.,V
%quickref -> Quick reference.,V
r,v
:,v
;,v
W,v
#          :::::::: ::::::::::: :::::::::  :::             :::::::::          #,V
H,v
" remap Mac Cmd-keysnmap <D-Right> <C-w>lnmap <D-Left> <C-w>h,V
nmap <D-Right> <C-w>lnmap <D-Left> <C-w>h,v
Hello world.,v
https://github.com/gmarik/Vundle.vim.git,v
autocmd FileType python compiler pylint,V
" PythonPlugin 'klen/python-mode',V
http://ninjiatext.blogspot.tw/2014/11/blog-post_16.html,v
LaTeX-Box-Team/LaTeX-Box,v
",v
,V
EasyMotion_hl_group_shade,v
Undefined variable: g:EasyMotion_hl_group_shade,v
    //$( alist[i].parentNode ).append( alist[i] );,V
    //$( alist[i].parentNode ).append( '<br></br>' );,V
DF,v
ervandew/supertab,v
~/.vim/dirs/tmp/.vimrc.swp,v
Lokaltog/vim-easymotion,v
https://raw.githubusercontent.com/oplatek/Conque-Shell/master/autoload/conque_term/conque_win32_util.py,v
https://raw.githubusercontent.com/oplatek/Conque-Shell/master/autoload/conque_term/conque.py,v
# FILE:     autoload/conque_term/conque.py # AUTHOR:   Nico Raffo <nicoraffo@gmail.com># WEBSITE:  http://conque.googlecode.com# MODIFIED: 2011-09-02# VERSION:  2.3, for Vim 7.0# LICENSE:# Conque - Vim terminal/console emulator# Copyright (C) 2009-2011 Nico Raffo## MIT License## Permission is hereby granted, free of charge, to any person obtaining a copy# of this software and associated documentation files (the "Software"), to deal# in the Software without restriction, including without limitation the rights# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell# copies of the Software, and to permit persons to whom the Software is# furnished to do so, subject to the following conditions:## The above copyright notice and this permission notice shall be included in# all copies or substantial portions of the Software.## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN# THE SOFTWARE."""Vim terminal emulator.This class is the main interface between Vim and the terminal application. It handles both updating the Vim buffer with new output and accepting new keyboardinput from the Vim user.Although this class was originally designed for a Unix terminal environment, ithas been extended by the ConqueSole class for Windows.Usage:    term = Conque()    term.open('/bin/bash', {'TERM': 'vt100'})    term.write("ls -lha\r")    term.read()    term.close()"""import vimimport reimport mathclass Conque:    # screen object    screen = None    # subprocess object    proc = None    # terminal dimensions and scrolling region    columns = 80 # same as $COLUMNS    lines = 24 # same as $LINES    working_columns = 80 # can be changed by CSI ? 3 l/h    working_lines = 24 # can be changed by CSI r    # top/bottom of the scroll region    top = 1 # relative to top of screen    bottom = 24 # relative to top of screen    # cursor position    l = 1 # current cursor line    c = 1 # current cursor column    # autowrap mode    autowrap = True    # absolute coordinate mode    absolute_coords = True    # tabstop positions    tabstops = []    # enable colors    enable_colors = True    # color changes    color_changes = {}    # color history    color_history = {}    # color highlight cache    highlight_groups = {}    # prune terminal colors    color_pruning = True    # don't wrap table output    unwrap_tables = True    # wrap CUF/CUB around line breaks    wrap_cursor = False    # do we need to move the cursor?    cursor_set = False    # current character set, ascii or graphics    character_set = 'ascii'    # used for auto_read actions    read_count = 0    # input buffer, array of ordinals    input_buffer = []    def open(self):        """ Start program and initialize this instance.         Arguments:        command -- Command string to execute, e.g. '/bin/bash --login'        options -- Dictionary of environment vars to set and other options.        """        # get arguments        command = vim.eval('command')        options = vim.eval('options')        # create terminal screen instance        self.screen = ConqueScreen()        # int vars        self.columns = vim.current.window.width        self.lines = vim.current.window.height        self.working_columns = vim.current.window.width        self.working_lines = vim.current.window.height        self.bottom = vim.current.window.height        # offset first line to make room for startup messages        if int(options['offset']) > 0:            self.l = int(options['offset'])        # init color        self.enable_colors = options['color'] and not CONQUE_FAST_MODE        # init tabstops        self.init_tabstops()        # open command        self.proc = ConqueSubprocess()        self.proc.open(command, {'TERM': options['TERM'], 'CONQUE': '1', 'LINES': str(self.lines), 'COLUMNS': str(self.columns)})        # send window size signal, in case LINES/COLUMNS is ignored        self.update_window_size(True)    def write(self, input, set_cursor=True, read=True):        """ Write a unicode string to the subprocess.         set_cursor -- Position the cursor in the current buffer when finished        read -- Check program for new output when finished        """        # write and read        self.proc.write(input)        # read output immediately        if read:            self.read(1, set_cursor)    def write_ord(self, input, set_cursor=True, read=True):        """ Write a single character to the subprocess, using an unicode ordinal. """        if CONQUE_PYTHON_VERSION == 2:            self.write(unichr(input), set_cursor, read)        else:            self.write(chr(input), set_cursor, read)            def write_expr(self, expr, set_cursor=True, read=True):        """ Write the value of a Vim expression to the subprocess. """        if CONQUE_PYTHON_VERSION == 2:            try:                val = vim.eval(expr)                self.write(unicode(val, CONQUE_VIM_ENCODING, 'ignore'), set_cursor, read)            except:                pass        else:            try:                # XXX - Depending on Vim to deal with encoding, sadly                self.write(vim.eval(expr), set_cursor, read)            except:                pass    def write_latin1(self, input, set_cursor=True, read=True):        """ Write latin-1 string to conque. Very ugly, shood be removed. """        # XXX - this whole method is a hack, to be removed soon        if CONQUE_PYTHON_VERSION == 2:            try:                input_unicode = input.decode('latin-1', 'ignore')                self.write(input_unicode.encode('utf-8', 'ignore'), set_cursor, read)            except:                return        else:            self.write(input, set_cursor, read)    def write_buffered_ord(self, chr):        """ Add character ordinal to input buffer. In case we're not allowed to modify buffer a time of input. """        self.input_buffer.append(chr)    def read(self, timeout=1, set_cursor=True, return_output=False, update_buffer=True):        """ Read new output from the subprocess and update the Vim buffer.        Arguments:        timeout -- Milliseconds to wait before reading input        set_cursor -- Set the cursor position in the current buffer when finished        return_output -- Return new subprocess STDOUT + STDERR as a string        update_buffer -- Update the current Vim buffer with the new output        This method goes through the following rough steps:            1. Get new output from subprocess            2. Split output string into control codes, escape sequences, or plain text            3. Loop over and process each chunk, updating the Vim buffer as we go        """        output = ''        # this may not actually work        try:            # read from subprocess and strip null characters            output = self.proc.read(timeout)            if output == '':                return            # for bufferless terminals            if not update_buffer:                return output            # strip null characters. I'm still not sure why they appear            output = output.replace(chr(0), '')            # split input into individual escape sequences, control codes, and text output            chunks = CONQUE_SEQ_REGEX.split(output)            # if there were no escape sequences, skip processing and treat entire string as plain text            if len(chunks) == 1:                self.plain_text(chunks[0])            # loop through and process escape sequences            else:                for s in chunks:                    if s == '':                        continue                    # Check for control character match                     if CONQUE_SEQ_REGEX_CTL.match(s[0]):                        nr = ord(s[0])                        if nr in CONQUE_CTL:                            getattr(self, 'ctl_' + CONQUE_CTL[nr])()                        else:                            pass                    # check for escape sequence match                     elif CONQUE_SEQ_REGEX_CSI.match(s):                        if s[-1] in CONQUE_ESCAPE:                            csi = self.parse_csi(s[2:])                            getattr(self, 'csi_' + CONQUE_ESCAPE[s[-1]])(csi)                        else:                            pass                    # check for title match                     elif CONQUE_SEQ_REGEX_TITLE.match(s):                        self.change_title(s[2], s[4:-1])                    # check for hash match                     elif CONQUE_SEQ_REGEX_HASH.match(s):                        if s[-1] in CONQUE_ESCAPE_HASH:                            getattr(self, 'hash_' + CONQUE_ESCAPE_HASH[s[-1]])()                        else:                            pass                    # check for charset match                     elif CONQUE_SEQ_REGEX_CHAR.match(s):                        if s[-1] in CONQUE_ESCAPE_CHARSET:                            getattr(self, 'charset_' + CONQUE_ESCAPE_CHARSET[s[-1]])()                        else:                            pass                    # check for other escape match                     elif CONQUE_SEQ_REGEX_ESC.match(s):                        if s[-1] in CONQUE_ESCAPE_PLAIN:                            getattr(self, 'esc_' + CONQUE_ESCAPE_PLAIN[s[-1]])()                        else:                            pass                    # else process plain text                     else:                        self.plain_text(s)            # set cusor position            if set_cursor:                self.screen.set_cursor(self.l, self.c)            # we need to set the cursor position            self.cursor_set = False        except:            pass        if return_output:            if CONQUE_PYTHON_VERSION == 3:                return output            else:                return output.encode(CONQUE_VIM_ENCODING, 'replace')    def auto_read(self):        """ Poll program for more output.         Since Vim doesn't have a reliable event system that can be triggered when new        output is available, we have to continually poll the subprocess instead. This        method is called many times a second when the terminal buffer is active, so it        needs to be very fast and efficient.        The feedkeys portion is required to reset Vim's timer system. The timer is used        to execute this command, typically set to go off after 50 ms of inactivity.        """        # process buffered input if any        if len(self.input_buffer):            for chr in self.input_buffer:                self.write_ord(chr, set_cursor=False, read=False)            self.input_buffer = []            self.read(1)        # check subprocess status, but not every time since it's CPU expensive        if self.read_count % 32 == 0:            if not self.proc.is_alive():                vim.command('call conque_term#get_instance().close()')                return            if self.read_count > 512:                self.read_count = 0                # trim color history occasionally if desired                if self.enable_colors and self.color_pruning:                    self.prune_colors()        # ++        self.read_count += 1        # read output        self.read(1)        # reset timer        if self.c == 1:            vim.command('call feedkeys("\<right>\<left>", "n")')        else:            vim.command('call feedkeys("\<left>\<right>", "n")')        # stop here if cursor doesn't need to be moved        if self.cursor_set:            return        # check if window size has changed        if not CONQUE_FAST_MODE:            self.update_window_size()        # otherwise set cursor position        try:            self.set_cursor(self.l, self.c)        except:            pass        self.cursor_set = True    def plain_text(self, input):        """ Write text output to Vim buffer.          This method writes a string of characters without any control characters or escape sequences        to the Vim buffer. In simple terms, it writes the input string to the buffer starting at the        current cursor position, wrapping the text to a new line if needed. It also triggers the         terminal coloring methods if needed.        """        # translate input into graphics character set if needed        if self.character_set == 'graphics':            old_input = input            input = u('')            for i in range(0, len(old_input)):                chrd = ord(old_input[i])                try:                    if chrd > 255:                        input = input + old_input[i]                    else:                        input = input + uchr(CONQUE_GRAPHICS_SET[chrd])                except:                    pass        # get current line from Vim buffer        current_line = self.screen[self.l]        # pad current line with spaces, if it's shorter than cursor position        if len(current_line) < self.c:            current_line = current_line + ' ' * (self.c - len(current_line))        # if line is wider than screen        if self.c + len(input) - 1 > self.working_columns:            # Table formatting hack            if self.unwrap_tables and CONQUE_TABLE_OUTPUT.match(input):                self.screen[self.l] = current_line[:self.c - 1] + input + current_line[self.c + len(input) - 1:]                self.apply_color(self.c, self.c + len(input))                self.c += len(input)                return            diff = self.c + len(input) - self.working_columns - 1            # if autowrap is enabled            if self.autowrap:                self.screen[self.l] = current_line[:self.c - 1] + input[:-1 * diff]                self.apply_color(self.c, self.working_columns)                self.ctl_nl()                self.ctl_cr()                remaining = input[-1 * diff:]                self.plain_text(remaining)            else:                self.screen[self.l] = current_line[:self.c - 1] + input[:-1 * diff - 1] + input[-1]                self.apply_color(self.c, self.working_columns)                self.c = self.working_columns        # no autowrap        else:            self.screen[self.l] = current_line[:self.c - 1] + input + current_line[self.c + len(input) - 1:]            self.apply_color(self.c, self.c + len(input))            self.c += len(input)    def apply_color(self, start, end, line=0):        """ Apply terminal colors to buffer for a range of characters in a single line.         When a text attribute escape sequence is encountered during input processing, the        attributes are recorded in the dictionary self.color_changes. After those attributes        have been applied, the changes are recorded in a second dictionary self.color_history.          This method inspects both dictionaries to calculate any syntax highlighting         that needs to be executed to render the text attributes in the Vim buffer.        """        # stop here if coloration is disabled        if not self.enable_colors:            return        # allow custom line nr to be passed        if line:            buffer_line = line        else:            buffer_line = self.get_buffer_line(self.l)        # check for previous overlapping coloration        to_del = []        if buffer_line in self.color_history:            for i in range(len(self.color_history[buffer_line])):                syn = self.color_history[buffer_line][i]                if syn['start'] >= start and syn['start'] < end:                    vim.command('syn clear ' + syn['name'])                    to_del.append(i)                    # outside                    if syn['end'] > end:                        self.exec_highlight(buffer_line, end, syn['end'], syn['highlight'])                elif syn['end'] > start and syn['end'] <= end:                    vim.command('syn clear ' + syn['name'])                    to_del.append(i)                    # outside                    if syn['start'] < start:                        self.exec_highlight(buffer_line, syn['start'], start, syn['highlight'])        # remove overlapped colors        if len(to_del) > 0:            to_del.reverse()            for di in to_del:                del self.color_history[buffer_line][di]        # if there are no new colors        if len(self.color_changes) == 0:            return        # build the color attribute string        highlight = ''        for attr in self.color_changes.keys():            highlight = highlight + ' ' + attr + '=' + self.color_changes[attr]        # execute the highlight        self.exec_highlight(buffer_line, start, end, highlight)    def exec_highlight(self, buffer_line, start, end, highlight):        """ Execute the Vim commands for a single syntax highlight """        syntax_name = 'ConqueHighLightAt_%d_%d_%d_%d' % (self.proc.pid, self.l, start, len(self.color_history) + 1)        syntax_options = 'contains=ALLBUT,ConqueString,MySQLString,MySQLKeyword oneline'        syntax_region = 'syntax match %s /\%%%dl\%%>%dc.\{%d}\%%<%dc/ %s' % (syntax_name, buffer_line, start - 1, end - start, end + 1, syntax_options)        # check for cached highlight group        hgroup = 'ConqueHL_%d' % (abs(hash(highlight)))        if hgroup not in self.highlight_groups:            syntax_group = 'highlight %s %s' % (hgroup, highlight)            self.highlight_groups[hgroup] = hgroup            vim.command(syntax_group)        # link this syntax match to existing highlight group        syntax_highlight = 'highlight link %s %s' % (syntax_name, self.highlight_groups[hgroup])        vim.command(syntax_region)        vim.command(syntax_highlight)        # add syntax name to history        if not buffer_line in self.color_history:            self.color_history[buffer_line] = []        self.color_history[buffer_line].append({'name': syntax_name, 'start': start, 'end': end, 'highlight': highlight})    def prune_colors(self):        """ Remove old syntax highlighting from the Vim buffer        The kind of syntax highlighting required for terminal colors can make        Conque run slowly. The prune_colors() method will remove old highlight definitions        to keep the maximum number of highlight rules within a reasonable range.        """        buffer_line = self.get_buffer_line(self.l)        ks = list(self.color_history.keys())        for line in ks:            if line < buffer_line - CONQUE_MAX_SYNTAX_LINES:                for syn in self.color_history[line]:                    vim.command('syn clear ' + syn['name'])                del self.color_history[line]    ###############################################################################################    # Control functions     def ctl_nl(self):        """ Process the newline control character. """        # if we're in a scrolling region, scroll instead of moving cursor down        if self.lines != self.working_lines and self.l == self.bottom:            del self.screen[self.top]            self.screen.insert(self.bottom, '')        elif self.l == self.bottom:            self.screen.append('')        else:            self.l += 1        self.color_changes = {}    def ctl_cr(self):        """ Process the carriage return control character. """        self.c = 1        self.color_changes = {}    def ctl_bs(self):        """ Process the backspace control character. """        if self.c > 1:            self.c += -1    def ctl_soh(self):        """ Process the start of heading control character. """        pass    def ctl_stx(self):        pass    def ctl_bel(self):        """ Process the bell control character. """        vim.command('call conque_term#bell()')    def ctl_tab(self):        """ Process the tab control character. """        # default tabstop location        ts = self.working_columns        # check set tabstops        for i in range(self.c, len(self.tabstops)):            if self.tabstops[i]:                ts = i + 1                break        self.c = ts    def ctl_so(self):        """ Process the shift out control character. """        self.character_set = 'graphics'    def ctl_si(self):        """ Process the shift in control character. """        self.character_set = 'ascii'    ###############################################################################################    # CSI functions     def csi_font(self, csi):        """ Process the text attribute escape sequence. """        if not self.enable_colors:            return        # defaults to 0        if len(csi['vals']) == 0:            csi['vals'] = [0]        # 256 xterm color foreground        if len(csi['vals']) == 3 and csi['vals'][0] == 38 and csi['vals'][1] == 5:            self.color_changes['ctermfg'] = str(csi['vals'][2])            self.color_changes['guifg'] = '#' + self.xterm_to_rgb(csi['vals'][2])        # 256 xterm color background        elif len(csi['vals']) == 3 and csi['vals'][0] == 48 and csi['vals'][1] == 5:            self.color_changes['ctermbg'] = str(csi['vals'][2])            self.color_changes['guibg'] = '#' + self.xterm_to_rgb(csi['vals'][2])        # 16 colors        else:            for val in csi['vals']:                if val in CONQUE_FONT:                    # ignore starting normal colors                    if CONQUE_FONT[val]['normal'] and len(self.color_changes) == 0:                        continue                    # clear color changes                    elif CONQUE_FONT[val]['normal']:                        self.color_changes = {}                    # save these color attributes for next plain_text() call                    else:                        for attr in CONQUE_FONT[val]['attributes'].keys():                            if attr in self.color_changes and (attr == 'cterm' or attr == 'gui'):                                self.color_changes[attr] += ',' + CONQUE_FONT[val]['attributes'][attr]                            else:                                self.color_changes[attr] = CONQUE_FONT[val]['attributes'][attr]    def csi_clear_line(self, csi):        """ Process the line clear escape sequence. """        # this escape defaults to 0        if len(csi['vals']) == 0:            csi['val'] = 0        # 0 means cursor right        if csi['val'] == 0:            self.screen[self.l] = self.screen[self.l][0:self.c - 1]        # 1 means cursor left        elif csi['val'] == 1:            self.screen[self.l] = ' ' * (self.c) + self.screen[self.l][self.c:]        # clear entire line        elif csi['val'] == 2:            self.screen[self.l] = ''        # clear colors        if csi['val'] == 2 or (csi['val'] == 0 and self.c == 1):            buffer_line = self.get_buffer_line(self.l)            if buffer_line in self.color_history:                for syn in self.color_history[buffer_line]:                    vim.command('syn clear ' + syn['name'])    def csi_cursor_right(self, csi):        """ Process the move cursor right escape sequence. """        # we use 1 even if escape explicitly specifies 0        if csi['val'] == 0:            csi['val'] = 1        if self.wrap_cursor and self.c + csi['val'] > self.working_columns:            self.l += int(math.floor((self.c + csi['val']) / self.working_columns))            self.c = (self.c + csi['val']) % self.working_columns            return        self.c = self.bound(self.c + csi['val'], 1, self.working_columns)    def csi_cursor_left(self, csi):        """ Process the move cursor left escape sequence. """        # we use 1 even if escape explicitly specifies 0        if csi['val'] == 0:            csi['val'] = 1        if self.wrap_cursor and csi['val'] >= self.c:            self.l += int(math.floor((self.c - csi['val']) / self.working_columns))            self.c = self.working_columns - (csi['val'] - self.c) % self.working_columns            return        self.c = self.bound(self.c - csi['val'], 1, self.working_columns)    def csi_cursor_to_column(self, csi):        """ Process the move cursor to column escape sequence. """        self.c = self.bound(csi['val'], 1, self.working_columns)    def csi_cursor_up(self, csi):        """ Process the move cursor up escape sequence. """        self.l = self.bound(self.l - csi['val'], self.top, self.bottom)        self.color_changes = {}    def csi_cursor_down(self, csi):        """ Process the move cursor down escape sequence. """        self.l = self.bound(self.l + csi['val'], self.top, self.bottom)        self.color_changes = {}    def csi_clear_screen(self, csi):        """ Process the clear screen escape sequence. """        # default to 0        if len(csi['vals']) == 0:            csi['val'] = 0        # 2 == clear entire screen        if csi['val'] == 2:            self.l = 1            self.c = 1            self.screen.clear()        # 0 == clear down        elif csi['val'] == 0:            for l in range(self.bound(self.l + 1, 1, self.lines), self.lines + 1):                self.screen[l] = ''            # clear end of current line            self.csi_clear_line(self.parse_csi('K'))        # 1 == clear up        elif csi['val'] == 1:            for l in range(1, self.bound(self.l, 1, self.lines + 1)):                self.screen[l] = ''            # clear beginning of current line            self.csi_clear_line(self.parse_csi('1K'))        # clear coloration        if csi['val'] == 2 or csi['val'] == 0:            buffer_line = self.get_buffer_line(self.l)            for line in self.color_history.keys():                if line >= buffer_line:                    for syn in self.color_history[line]:                        vim.command('syn clear ' + syn['name'])        self.color_changes = {}    def csi_delete_chars(self, csi):        self.screen[self.l] = self.screen[self.l][:self.c] + self.screen[self.l][self.c + csi['val']:]    def csi_add_spaces(self, csi):        self.screen[self.l] = self.screen[self.l][: self.c - 1] + ' ' * csi['val'] + self.screen[self.l][self.c:]    def csi_cursor(self, csi):        if len(csi['vals']) == 2:            new_line = csi['vals'][0]            new_col = csi['vals'][1]        else:            new_line = 1            new_col = 1        if self.absolute_coords:            self.l = self.bound(new_line, 1, self.lines)        else:            self.l = self.bound(self.top + new_line - 1, self.top, self.bottom)        self.c = self.bound(new_col, 1, self.working_columns)        if self.c > len(self.screen[self.l]):            self.screen[self.l] = self.screen[self.l] + ' ' * (self.c - len(self.screen[self.l]))    def csi_set_coords(self, csi):        if len(csi['vals']) == 2:            new_start = csi['vals'][0]            new_end = csi['vals'][1]        else:            new_start = 1            new_end = vim.current.window.height        self.top = new_start        self.bottom = new_end        self.working_lines = new_end - new_start + 1        # if cursor is outside scrolling region, reset it        if self.l < self.top:            self.l = self.top        elif self.l > self.bottom:            self.l = self.bottom        self.color_changes = {}    def csi_tab_clear(self, csi):        # this escape defaults to 0        if len(csi['vals']) == 0:            csi['val'] = 0        if csi['val'] == 0:            self.tabstops[self.c - 1] = False        elif csi['val'] == 3:            for i in range(0, self.columns + 1):                self.tabstops[i] = False    def csi_set(self, csi):        # 132 cols        if csi['val'] == 3:            self.csi_clear_screen(self.parse_csi('2J'))            self.working_columns = 132        # relative_origin        elif csi['val'] == 6:            self.absolute_coords = False        # set auto wrap        elif csi['val'] == 7:            self.autowrap = True        self.color_changes = {}    def csi_reset(self, csi):        # 80 cols        if csi['val'] == 3:            self.csi_clear_screen(self.parse_csi('2J'))            self.working_columns = 80        # absolute origin        elif csi['val'] == 6:            self.absolute_coords = True        # reset auto wrap        elif csi['val'] == 7:            self.autowrap = False        self.color_changes = {}    ###############################################################################################    # ESC functions     def esc_scroll_up(self):        self.ctl_nl()        self.color_changes = {}    def esc_next_line(self):        self.ctl_nl()        self.c = 1    def esc_set_tab(self):        if self.c <= len(self.tabstops):            self.tabstops[self.c - 1] = True    def esc_scroll_down(self):        if self.l == self.top:            del self.screen[self.bottom]            self.screen.insert(self.top, '')        else:            self.l += -1        self.color_changes = {}    ###############################################################################################    # HASH functions     def hash_screen_alignment_test(self):        self.csi_clear_screen(self.parse_csi('2J'))        self.working_lines = self.lines        for l in range(1, self.lines + 1):            self.screen[l] = 'E' * self.working_columns    ###############################################################################################    # CHARSET functions     def charset_us(self):        self.character_set = 'ascii'    def charset_uk(self):        self.character_set = 'ascii'    def charset_graphics(self):        self.character_set = 'graphics'    ###############################################################################################    # Random stuff     def set_cursor(self, line, col):        """ Set cursor position in the Vim buffer.        Note: the line and column numbers are relative to the top left corner of the         visible screen. Not the line number in the Vim buffer.        """        self.screen.set_cursor(line, col)    def change_title(self, key, val):        """ Change the Vim window title. """        if key == '0' or key == '2':            vim.command('setlocal statusline=' + re.escape(val))            try:                vim.command('set titlestring=' + re.escape(val))            except:                pass    def update_window_size(self, force=False):        """ Check and save the current buffer dimensions.        If the buffer size has changed, the update_window_size() method both updates        the Conque buffer size attributes as well as sending the new dimensions to the        subprocess pty.        """        # resize if needed        if force or vim.current.window.width != self.columns or vim.current.window.height != self.lines:            # reset all window size attributes to default            self.columns = vim.current.window.width            self.lines = vim.current.window.height            self.working_columns = vim.current.window.width            self.working_lines = vim.current.window.height            self.bottom = vim.current.window.height            # reset screen object attributes            self.l = self.screen.reset_size(self.l)            # reset tabstops            self.init_tabstops()            # signal process that screen size has changed            self.proc.window_resize(self.lines, self.columns)    def insert_enter(self):        """ Run commands when user enters insert mode. """        # check window size        self.update_window_size()        # we need to set the cursor position        self.cursor_set = False    def init_tabstops(self):        """ Intitialize terminal tabstop positions. """        for i in range(0, self.columns + 1):            if i % 8 == 0:                self.tabstops.append(True)            else:                self.tabstops.append(False)    def idle(self):        """ Called when this terminal becomes idle. """        pass    def resume(self):        """ Called when this terminal is no longer idle. """        pass        pass    def close(self):        """ End the process running in the terminal. """        self.proc.close()    def abort(self):        """ Forcefully end the process running in the terminal. """        self.proc.signal(1)    ###############################################################################################    # Utility     def parse_csi(self, s):        """ Parse an escape sequence into it's meaningful values. """        attr = {'key': s[-1], 'flag': '', 'val': 1, 'vals': []}        if len(s) == 1:            return attr        full = s[0:-1]        if full[0] == '?':            full = full[1:]            attr['flag'] = '?'        if full != '':            vals = full.split(';')            for val in vals:                val = re.sub("\D", "", val)                if val != '':                    attr['vals'].append(int(val))        if len(attr['vals']) == 1:            attr['val'] = int(attr['vals'][0])        return attr    def bound(self, val, min, max):        """ TODO: This probably exists as a builtin function. """        if val > max:            return max        if val < min:            return min        return val    def xterm_to_rgb(self, color_code):        """ Translate a terminal color number into a RGB string. """        if color_code < 16:            ascii_colors = ['000000', 'CD0000', '00CD00', 'CDCD00', '0000EE', 'CD00CD', '00CDCD', 'E5E5E5',                   '7F7F7F', 'FF0000', '00FF00', 'FFFF00', '5C5CFF', 'FF00FF', '00FFFF', 'FFFFFF']            return ascii_colors[color_code]        elif color_code < 232:            cc = int(color_code) - 16            p1 = "%02x" % (math.floor(cc / 36) * (255 / 5))            p2 = "%02x" % (math.floor((cc % 36) / 6) * (255 / 5))            p3 = "%02x" % (math.floor(cc % 6) * (255 / 5))            return p1 + p2 + p3        else:            grey_tone = "%02x" % math.floor((255 / 24) * (color_code - 232))            return grey_tone + grey_tone + grey_tone    def get_buffer_line(self, line):        """ Get the buffer line number corresponding to the supplied screen line number. """        return self.screen.get_buffer_line(line),V
https://github.com/oplatek/Conque-Shell/blob/master/autoload/conque_term/conque_sole_subprocess.py,v
